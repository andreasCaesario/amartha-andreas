package usecase

import (
	"amartha-andreas/internal/domain/entity"
	"amartha-andreas/internal/domain/repository"
	"amartha-andreas/internal/domain/service"
	"context"
	"fmt"
	"time"
)

// LoanUsecase defines the interface for loan business logic
type LoanUsecase interface {
	CreateLoan(ctx context.Context, params entity.CreateLoanParams) (*entity.Loan, error)
	ApproveLoan(ctx context.Context, loanID int64, params entity.ApproveLoanParams) (*entity.Loan, error)
	InvestInLoan(ctx context.Context, loanID int64, params entity.InvestLoanParams) (*entity.Investment, error)
	DisburseLoan(ctx context.Context, loanID int64, params entity.DisburseLoanParams) (*entity.Loan, error)
	GetLoan(ctx context.Context, loanID int64) (*LoanSummary, error)
	ListLoans(ctx context.Context, filter repository.LoanFilter) ([]*entity.Loan, error)
}

// loanUsecase implements LoanUsecase interface
type loanUsecase struct {
	loanRepo       repository.LoanRepository
	investmentRepo repository.InvestmentRepository
	emailService   service.EmailService
}

// NewLoanUsecase creates a new loan usecase
func NewLoanUsecase(loanRepo repository.LoanRepository, investmentRepo repository.InvestmentRepository, emailService service.EmailService) LoanUsecase {
	return &loanUsecase{
		loanRepo:       loanRepo,
		investmentRepo: investmentRepo,
		emailService:   emailService,
	}
}

// LoanSummary represents a complete loan summary with investments
type LoanSummary struct {
	Loan            *entity.Loan         `json:"loan"`
	TotalInvested   float64              `json:"total_invested"`
	RemainingAmount float64              `json:"remaining_amount"`
	InvestmentCount int                  `json:"investment_count"`
	Investments     []*entity.Investment `json:"investments"`
}

// CreateLoan creates a new loan with proposed state
func (uc *loanUsecase) CreateLoan(ctx context.Context, params entity.CreateLoanParams) (*entity.Loan, error) {
	loan := &entity.Loan{
		// ID will be auto-generated by database
		BorrowerIDNumber:    params.BorrowerIDNumber,
		PrincipalAmount:     params.PrincipalAmount,
		Rate:                params.Rate,
		ROI:                 params.ROI,
		State:               entity.StateProposed,
		AgreementLetterLink: params.AgreementLetterLink,
		CreatedAt:           time.Now(),
		UpdatedAt:           time.Now(),
	}

	if err := uc.loanRepo.Create(ctx, loan); err != nil {
		return nil, fmt.Errorf("failed to create loan: %w", err)
	}

	return loan, nil
}

// ApproveLoan approves a loan and moves it to approved state
func (uc *loanUsecase) ApproveLoan(ctx context.Context, loanID int64, params entity.ApproveLoanParams) (*entity.Loan, error) {
	// Get existing loan
	loan, err := uc.loanRepo.GetByID(ctx, loanID)
	if err != nil {
		return nil, fmt.Errorf("failed to get loan: %w", err)
	}

	// Apply business rules
	if err := loan.Approve(params.ProofPicture, params.EmployeeID, params.ApprovalDate); err != nil {
		return nil, err
	}

	// Update loan
	if err := uc.loanRepo.Update(ctx, loan); err != nil {
		return nil, fmt.Errorf("failed to update loan: %w", err)
	}

	return loan, nil
}

// InvestInLoan allows investors to invest in an approved loan
func (uc *loanUsecase) InvestInLoan(ctx context.Context, loanID int64, params entity.InvestLoanParams) (*entity.Investment, error) {
	// Get existing loan
	loan, err := uc.loanRepo.GetByID(ctx, loanID)
	if err != nil {
		return nil, fmt.Errorf("failed to get loan: %w", err)
	}

	// Check if loan can receive investment
	if err := loan.CanReceiveInvestment(); err != nil {
		return nil, err
	}

	// Get current total investment
	totalInvestment, err := uc.investmentRepo.GetTotalByLoanID(ctx, loanID)
	if err != nil {
		return nil, fmt.Errorf("failed to get total investment: %w", err)
	}

	// Validate investment amount
	if err := loan.ValidateInvestmentAmount(params.Amount, totalInvestment); err != nil {
		return nil, err
	}

	// Create investment
	investment := &entity.Investment{
		// ID will be auto-generated by database
		LoanID:        loanID,
		InvestorEmail: params.InvestorEmail,
		Amount:        params.Amount,
		CreatedAt:     time.Now(),
	}

	if err := uc.investmentRepo.Create(ctx, investment); err != nil {
		return nil, fmt.Errorf("failed to create investment: %w", err)
	}

	// Check if loan is now fully invested
	newTotalInvestment := totalInvestment + params.Amount
	if loan.IsFullyInvested(newTotalInvestment) {
		loan.MarkAsInvested()
		if err := uc.loanRepo.Update(ctx, loan); err != nil {
			return nil, fmt.Errorf("failed to update loan state to invested: %w", err)
		}

		// Send email to all investors with agreement letter
		if err := uc.sendLoanFullyInvestedNotification(ctx, loanID, loan); err != nil {
			// Log error but don't fail the transaction
			fmt.Printf("Failed to send loan fully invested notification: %v\n", err)
		}
	}

	return investment, nil
}

// DisburseLoan disburses a fully invested loan
func (uc *loanUsecase) DisburseLoan(ctx context.Context, loanID int64, params entity.DisburseLoanParams) (*entity.Loan, error) {
	// Get existing loan
	loan, err := uc.loanRepo.GetByID(ctx, loanID)
	if err != nil {
		return nil, fmt.Errorf("failed to get loan: %w", err)
	}

	// Apply business rules
	if err := loan.Disburse(params.SignedAgreementDoc, params.EmployeeID, params.DisbursementDate); err != nil {
		return nil, err
	}

	// Update loan
	if err := uc.loanRepo.Update(ctx, loan); err != nil {
		return nil, fmt.Errorf("failed to update loan: %w", err)
	}

	return loan, nil
}

// GetLoan retrieves a loan with its investment summary
func (uc *loanUsecase) GetLoan(ctx context.Context, loanID int64) (*LoanSummary, error) {
	// Get loan
	loan, err := uc.loanRepo.GetByID(ctx, loanID)
	if err != nil {
		return nil, fmt.Errorf("failed to get loan: %w", err)
	}

	// Get investments
	investments, err := uc.investmentRepo.GetByLoanID(ctx, loanID)
	if err != nil {
		return nil, fmt.Errorf("failed to get investments: %w", err)
	}

	// Calculate totals
	var totalInvested float64
	for _, inv := range investments {
		totalInvested += inv.Amount
	}

	summary := &LoanSummary{
		Loan:            loan,
		TotalInvested:   totalInvested,
		RemainingAmount: loan.GetRemainingAmount(totalInvested),
		InvestmentCount: len(investments),
		Investments:     investments,
	}

	return summary, nil
}

// ListLoans retrieves loans with optional filtering
func (uc *loanUsecase) ListLoans(ctx context.Context, filter repository.LoanFilter) ([]*entity.Loan, error) {
	loans, err := uc.loanRepo.List(ctx, filter)
	if err != nil {
		return nil, fmt.Errorf("failed to list loans: %w", err)
	}

	return loans, nil
}

// sendLoanFullyInvestedNotification sends notification when loan is fully invested
func (uc *loanUsecase) sendLoanFullyInvestedNotification(ctx context.Context, loanID int64, loan *entity.Loan) error {
	// Get all investors for this loan
	investments, err := uc.investmentRepo.GetByLoanID(ctx, loanID)
	if err != nil {
		return fmt.Errorf("failed to get investments: %w", err)
	}

	// Collect unique investor emails
	emailMap := make(map[string]bool)
	for _, inv := range investments {
		emailMap[inv.InvestorEmail] = true
	}

	var investorEmails []string
	for email := range emailMap {
		investorEmails = append(investorEmails, email)
	}

	// Prepare email request
	emailRequest := service.SendLoanNotificationRequest{
		LoanID:              loanID,
		InvestorEmails:      investorEmails,
		BorrowerIDNumber:    loan.BorrowerIDNumber,
		PrincipalAmount:     loan.PrincipalAmount,
		AgreementLetterLink: loan.AgreementLetterLink,
	}

	// Send email notification
	return uc.emailService.SendLoanFullyInvestedNotification(ctx, emailRequest)
}
